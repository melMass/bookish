import bookish.parser.bootstrap as bs
import bookish.parser.rules as r
import bookish.wiki.wikipages as w
import bookish.util as util


any_ = r.any_

# Literal whitespace matchers

hspace = /[ \t]/
hspaces = /[ \t]*/
vspace =  "\r\n" | [\r\n]
space = /[ \t\r\n]/

# Literal whitespace or punctuation matcher

spaceorpunct = [ \t\r\n-;:'",./?]

# Any amount of whitespace

ws = (hspace | vspace)*

# One or more blank lines

emptylines = (r.linestart hspaces "\n")+

# Rules for matching changes of indentation

indentchange = emptylines? lstart:nextin ?(nextin != indent)
indentinc = emptylines? lstart:nextin ?(nextin > indent)
indentdec = emptylines? lstart:nextin ?(nextin < indent)

# Match the start of a line and return the indentation level

lstart = emptylines? r.linestart hspaces:indent -> len(indent)


# Numbers, letters, and characters

digit = [0123456789]
alphachar = any_:c ?(c.isalpha()) -> c

# XML-style character entities, e.g. &#1024;

charhex = "x" <[0123456789abcdefABCDEF]+>:h -> int(h, 16)
chardec = <digit+>:d -> int(d)
charnum = (charhex | chardec)
num_entity = "#" charnum:num -> util.unichr(num)
named_entity = /[A-Za-z]+/:n -> util.decode_named_entity(n)
entity = "&" (num_entity | named_entity):char ";" -> char

# Python identifier and XML name rules

xchar = [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789]
xname = ~~xchar </[-A-Za-z_0-9]+/>
identifier = ~~xchar </[A-Za-z_0-9]+/>

# Typographic niceties - curly apostrophe and quotes, dashes, symbols, etc.

apos = ^alphachar "'" ~~([Ss] | "ll" | "LL" | [Tt] | "nt" | "NT") -> u"\u2019"
dashes = ~^"-" ("---" | "--"):d ~"-" -> u"\u2014" if len(d) == 3 else u"\u2013"
arrows =  ("<-" -> u"\u2190"
           | "->" -> u"\u2192"
           | "<=" -> u"\u2264"
           | "=>" -> u"\u2265"
           | "<=>" -> u"\u21d4"
           ):c (r.lineend | ~~space) -> ' ' + c
symbols = ("(c)" -> u"\u00a9"
           | "(tm)" -> u"\u2122"
           | "(r)" -> u"\u00ae"
           ):c ~~spaceorpunct -> c
elipsis = "..." -> u"\u2026"
mult = ^digit "x" ~~(digit | hspace | r.streamend) -> u"\u00d7"

quotes = '"' @('"', inline):tx '"' -> w.span("q", tx)

# Union of all the typographic replacements

typog = apos | dashes | arrows | symbols | elipsis | mult | quotes


# Non block/span markup

html_comment = "<!--" @("-->") "-->" -> ''
line_comment = >[ /] r.linestart:indent hspace* "//" @(r.lineend) r.lineend -> ""
comment = >[< /] html_comment | line_comment

# Span markup

wordstart = r.streamstart | ~^r.alphanum
wordend = r.streamend | ~~~r.alphanum

uisep = space+ ">" space+ -> u" \u25b8 "
ui = wordstart ~^"_" "__" @(("__" | .(break_)), (uisep | inline)):tx "__" wordend ~~~"_" -> w.span("ui", tx)

var = ~^"<" "<<" @((">>" | .(break_)), inline):tx ">>" ~~~">" -> w.span("var", tx)
strong = wordstart ~^"*" "*" @(("*" | .(break_)), inline):tx "*" wordend ~~~"*" -> w.span("strong", tx)
em =  wordstart ~^"_" "_" @(("_" | .(break_)), inline):tx "_" ~~~"_" wordend -> w.span("em", tx)
code = "`" @(("`" | .(break_)), var):tx "`" -> w.span("code", tx)
#literal = "@<" @(">@"):tx ">@" -> tx
env = "%{" identifier:n "}" -> w.span("env", [], name=n)
glyph = "+(" <@((")" | .(break_)))>:v ")" -> w.span("link", None, scheme="Glyph", value=v)

# Rules for matching embedded XML

attr = ws xname:k "=\"" <@('"')>:v '"' -> (k, v)
attrlist = attr*:attrs -> dict(attrs)
ctag(n) = "</" xname:name ?(n == name) ">"
xml = "<" xname:n attrlist:alist ws "/>" -> w.span("xml", '', tag=n, attrs=alist)
      | "<" xname:n attrlist:alist ws ">"
        ??(_stream.find("</%s>" % _context['n'], _i) >= 0)
        @(("</"), spans):tx ctag(n)
        -> w.span("xml", tx, tag=n, attrs=alist)

# Key spans

keyname = <@((' ' | "))"))>
keys = "(("
       (hspace+ keyname | ~"(" keyname):k
       (hspace* "+" hspace* keyname)*:kk
       hspace* "))"
       -> w.span("keys", None, keys=[k] + kk)

# Links

targetre = /((?P<name>[A-Z][-_.A-Za-z0-9]*):)?(?P<value>[^\]\n|]*)/
anonlink = "[" targetre "]" -> w.span("link", '', scheme=name, value=value)
textlink = "[" @("|", stylespans):tx "|" targetre "]"
           -> w.span("link", tx, scheme=name, value=value)
link = anonlink | textlink

# Unions of different span matchers (for different content types)

stylespans = comment | entity | xml | var | em | typog | env | code | glyph | link | .(break_)
spans = comment | entity | xml | link | code | var | ui | strong | em | keys | typog | env | glyph
inline = spans | .(break_)


# Block markup

break_ = r.blockbreak | r.streamend | "\n" ~~starters

# "Normal" paragraph, but the "ending" matcher can change the paragraph type
# based on the last few characters

para_ending = ":" hspace* "\n" ~~indentinc emptylines? -> ("dt", None)
              | "||" hspace* "\n" -> ("cell", "th")
              | "|" hspace* "\n" ~~indentinc -> ("cell", "td")
              | break_ -> ("para", None)

para = lstart:indent @(para_ending, spans):tx para_ending:nd -> w.block(nd[0], indent, tx, role=nd[1])

# Bullet and numbered lists

bullet_start = [-*]+:bs " "+:space -> len(bs) + len(space)
ord_start = "#"+:ns " "+:space -> len(ns) + len(space)
bullet_ending = r.streamend
                | "\n" (emptylines | (ws? r.streamend))
                | "\n" ~~(lstart:nextin ?(nextin < indent or nextin > indent + bwidth))
                | "\n" ~~starters

bullet_body = @(bullet_ending, spans):tx bullet_ending -> tx
bullet = lstart:indent bullet_start:bwidth bullet_body:tx -> w.block('bullet', indent, tx, blevel=indent+bwidth)
ord = lstart:indent ord_start:bwidth bullet_body:tx -> w.block('ord', indent, tx, blevel=indent+bwidth)

divider = lstart:indent "~~" hspace* r.lineend -> w.block("divider", indent, None)
sepend = '~'* r.lineend
sep = lstart:indent '~'{2,}:line @(sepend, stylespans):tx sepend -> w.block("sep", indent, tx, level=len(line))

codeblock = lstart:indent "{{{"
            (ws "#!" identifier | !(None)):lang
            @("}}}"):tx
            "}}}" (r.lineend | r.streamend)
            -> w.block("pre", indent, tx, lang=lang)

supertitle = @((hspace* "|>"), stylespans):tx hspace* "|>" -> w.span("supertitle", tx)
subtitle = "<|" hspace* @((hspace* "="), stylespans):tx -> w.span("subtitle", tx)
title = lstart:indent "=" hspace*
        supertitle?:supt
        @((hspace* "=" | "<|"), stylespans):tx
        subtitle?:subt
        hspace* "="
        hspace* ("\n" | r.streamend)
        -> w.block("title", indent, supt + tx + subt, level=0)

heading_tag = hspace* "(" <(~")" r.any_)+>:tag ")" -> tag
heading = lstart:indent "="{2,}:eqs ?(len(eqs) > 1) hspace*
          @((hspace* "="), stylespans):tx
          hspace* "="{2,}:eqs2 ?(eqs == eqs2)
          heading_tag?:tag
          hspace* ("\n" | r.streamend)
          -> w.block("h", indent, tx, level=len(eqs), id=tag[0] if tag else None, container=True)

section = emptylines?
          lstart:indent '@' identifier:n
          hspace*
          @(r.lineend, stylespans):tx
          ('\n' | r.streamend)
          -> w.block(n + "_section", indent, tx, level=1, role="section", id=n, container=True)

summary = lstart:indent '"""' @((break_ | '"""'), spans):tx '"""' hspace* break_ -> w.block("summary", indent, tx)

itemname = identifier?:n -> n[0] if n else None
itemext = hspace+ (bs.dqstring | @(':', bs.escchar)):s -> ''.join(s)
itemtype = ':' itemname:n (?(n) itemext)?:ext ':' -> (n, ext[0] if ext else None)
itemend = ':'? hspace* break_
item = lstart:indent
       itemtype:it
       @(itemend, spans):tx
       itemend
       -> w.block(it[0] or "item", indent, tx, role="item", ext=it[1])

note = lstart:indent
       ("TIP" | "NOTE" | "WARNING"):it ':'
       @('\n', stylespans):tx '\n' ~~indentinc
       -> w.block(it.lower(), indent, tx, role="item")

property = lstart:indent '#' <@([:\n ])>:k ':' hspace*
           <@(r.lineend)>:v r.lineend
           (
               ~~(lstart:nextin ?(nextin > indent))
               /[^\n]*/:line ?(line.strip()) r.lineend
               -> line
           )*:extras
           emptylines?
           -> w.block("prop", indent, None, name=k, value=v + "".join(extras))

pxml = lstart:indent
       xname:n attrlist:alist ">>"
       @(r.lineend, spans):tx r.lineend
       -> w.block("pxml", indent, tx, tag=n, attrs=alist)


# Union of block rules

blocks = !!block x(
            codeblock
            | title
            | heading
            | summary
            | divider
            | sep
            | bullet
            | ord
            | item
            | note
            | property
            | pxml
            | section
            | para
            )

# "Starters" for blocks that don't require a blank line above them

starters = r.linestart hspaces
           (bullet_start
            | ord_start
            | '=='
            | itemtype
            | "{{{"
            | "~~"
            | "//"
           )


# Main rule

grammar = (blocks*):b ws r.streamend -> [blk for blk in b if blk]
