from collections import defaultdict

from bookish.parser import rules


fixed_imports = [
    "import re",
    "from bookish.parser import rules",
    "from bookish.parser.rules import Empty, Failure, Miss",
]

message = """
# This file was GENERATED from a grammar file. Do not edit this file; edit the
# grammar file and regenerate.

"""


class Frame(object):
    def __init__(self, name, counter=0, indent=4):
        self.name = name
        self.output = []
        self.counters = defaultdict(int)
        self.indent = indent

    def __repr__(self):
        return "<%s %r %r %s>" % (type(self).__name__, self.name, self.counters,
                                  self.indent)

    def inc(self, name):
        self.counters[name] += 1
        return self.counters[name]


class Indentation(object):
    def __init__(self, builder, amount):
        self.builder = builder
        self.amount = amount

    def __enter__(self):
        self.builder.add_indent(self.amount)

    def __exit__(self, *args):
        self.builder.sub_indent(self.amount)


class Builder(object):
    def __init__(self, imports, rules, main_rule, context):
        self.fixed_imports = list(fixed_imports)
        self.imports = imports
        self.rules = rules
        self.main_rule = main_rule
        self.context = context
        self.assigns = []
        self._constant_cache = {}
        self.stack = [Frame("<TOP>")]
        self.output = []
        self.made = set()

    def indented(self, amount):
        return Indentation(self, amount)

    def add_indent(self, n):
        self.stack[-1].indent += n

    def sub_indent(self, n):
        self.stack[-1].indent -= n

    def generate_id(self, prefix, save=False, top_level=False):
        frame_index = 0 if top_level else -1
        frame = self.stack[frame_index]
        name = "%s%s" % (prefix, frame.inc(prefix))
        return name

    def effective_name(self, rule):
        if isinstance(rule, rules.Call2):
            return "%s.%s" % (rule.modname, rule.name)
        elif isinstance(rule, rules.Call):
            self.make_function(rule.resolve(self.context))
            return rule.name
        else:
            return self.make_function(rule)

    def add_regex(self, pattern, expr):
        name = self.generate_id("_regex", top_level=True)
        self.assign(name, "re.compile(%r)" % expr.pattern)
        return name

    def add_constant(self, prefix, value):
        cache = self._constant_cache
        if value in cache:
            name = cache[value]
        else:
            name = self.generate_id(prefix, top_level=True)
            self.assign(name, value)
            cache[value] = name

        return name

    def assign(self, name, value):
        self.assigns.append("%s = %s" % (name, value))

    def make_function(self, rule):
        name = rule.rulename()
        if name and name in self.made:
            return name
        if not name:
            name = self.generate_id("anon_" + type(rule).__name__.lower(),
                                    top_level=True)
            rule.set_name(name)
        self.made.add(name)

        # [Frame name, line buffer, id counter, indent]
        self.stack.append(Frame(name))
        rule.build(self)
        frame = self.stack.pop()
        assert frame.name == name
        self.output.append("def %s(stream, i, context):" % frame.name)
        self.output.append("    # %r" % rule)
        # self.output.append("    print(%r, i, len(stream))" % name)
        self.output.extend(frame.output)
        # self.output.append("    print('-->', out, i)")
        self.output.append("    return out, i")
        self.output.append("\n")

        return name

    def line(self, line, indent=0):
        frame = self.stack[-1]
        frame.output.append((" " * (frame.indent + indent)) + line)

    def call(self, rule, indent=0, external=False):
        name = rule.rulename()
        if external and not name:
            name = self.make_function(rule)

        if name:
            if name not in self.made:
                self.make_function(rule)
            self.line("out, i = %s(stream, i, context)" % rule.rulename(),
                      indent=indent)
        else:
            self.stack[-1].indent += indent
            self.line("# " + repr(rule))
            rule.build(self)
            self.stack[-1].indent -= indent

    def call_by_name(self, name, indent=0, context_name="context"):
        if name not in self.made:
            self.make_function(self.rules[name])
        self.line("out, i = %s(stream, i, %s)" % (name, context_name),
                  indent=indent)

    def run(self):
        self.make_function(self.main_rule)
        imports = self.fixed_imports
        imports += ["import %s as %s" % (qid, n)
                    for n, qid in self.imports.items()]
        lines = imports + [message] + self.output + self.assigns
        return "\n".join(lines) + "\n\n"


